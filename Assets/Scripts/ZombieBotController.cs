using System.Linq;
using UnityEngine;
using UnityEngine.AI;

public class ZombieBotController : MonoBehaviour
{
     // Enum representing different states of the zombie
    public enum ZombieState
    {
        AiWalking,
        AiRunning,
        AiAttacking,
        Controlled,
        Ragdoll,
    }
    public ZombieState currentState; // Current state of the zombie

    // Private variables for various components and targets
    private Transform targetTransform; // Target to follow or attack (usually the player)
    private PlayerHealth playerHealth; // Health component of the player
    private NavMeshAgent navMeshAgent; // Navigation mesh agent for AI movement
    private NavMeshPath navMeshPath; // Path generated by the NavMeshAgent

    // Public variables for configurable parameters
    public float rotationSpeed = 125; // Speed at which the zombie rotates
    public float walkingSpeed => Random.Range(0.4f, 0.78f); // Walking speed, randomly chosen
    public float runningSpeed => Random.Range(0.78f, 1f); // Running speed, randomly chosen
    public float runningOuterProximity = 6f; // Distance at which the zombie starts running
    public float xzAttackProximity = 1.32f; // XZ proximity to initiate an attack
    public float yAttackProximity = 1.5f; // Y proximity to initiate an attack

    // Animator and related variables
    private Animator animator; // Animator component for animations
    private int isWalkingHash; // Hash of the 'isWalking' animation parameter
    private int isRunningHash; // Hash of the 'isRunning' animation parameter
    private int isAttackingHash; // Hash of the 'isAttacking' animation parameter

    // Ragdoll components
    private Rigidbody[] ragdollRigidbodies; // Array of ragdoll rigidbodies
    private CharacterController characterController; // Character controller for movement

    // Health and control parameters
    public float maxHealth = 3f; // Maximum health of the zombie
    public float controlledMovementSpeed = 2.0f; // Speed when manually controlled
    private float currentHealth; // Current health of the zombie
    public bool isDead = false; // Flag indicating if the zombie is dead

    // Audio components and variables
    private AudioSource attackAudioSource; // Audio source for attack sounds
    private float attackSoundCooldown = 2.0f; // Cooldown for attack sounds
    private float lastAttackSoundTime = -1.0f; // Time when the last attack sound played
    private AudioSource hurtAudioSource; // Audio source for hurt sounds

    // Controlled movement variables
    public Vector2 controlledMovementVector; // Movement vector when controlled
    private bool isControlledRunning; // Flag indicating if the zombie is running when controlled

    void Awake()
    {
        // Initialization code, acquiring components and setting default values
        targetTransform = GameObject.FindGameObjectWithTag("Player").transform;
        playerHealth = targetTransform.GetComponent<PlayerHealth>();
        navMeshAgent = GetComponent<UnityEngine.AI.NavMeshAgent>();
        navMeshAgent.SetDestination(targetTransform.position);
        navMeshPath = new NavMeshPath();

        ragdollRigidbodies = GetComponentsInChildren<Rigidbody>();
        characterController = GetComponent<CharacterController>();

        attackAudioSource = GetComponents<AudioSource>().First(e => e.clip.name == "Zombieattack 1");
        hurtAudioSource = GetComponents<AudioSource>().First(e => e.clip.name == "ZombieHurt");

        animator = GetComponent<Animator>();
        isWalkingHash = Animator.StringToHash("isWalking");
        isRunningHash = Animator.StringToHash("isRunning");
        isAttackingHash = Animator.StringToHash("isAttacking");

        runningOuterProximity = Random.Range(3f, 9f);
        currentHealth = maxHealth;

        isDead = false;

        StartAiWalking();
    }

    void Update()
    {
        // Main update loop, calls behavior methods based on current state
        switch (currentState)
        {
            case ZombieState.AiWalking:
                AiWalkingBehaviour();
                break;
            case ZombieState.AiRunning:
                RunningAiBehaviour();
                break;
            case ZombieState.AiAttacking:
                AiAttackingBehaviour();
                break;
            case ZombieState.Controlled:
                ControllingBehaviour();
                break;
            case ZombieState.Ragdoll:
                RagdollBehaviour();
                break;
        }
    }

    // Methods for enabling and disabling ragdoll physics
    private void DisableRagdoll()
    {
        // Makes all ragdoll rigidbodies kinematic and re-enables the animator and character controller
        foreach (var rigidbody in ragdollRigidbodies)
            rigidbody.isKinematic = true;

        animator.enabled = true;
        characterController.enabled = true;
    }

    private void EnableRagdoll()
    {
        // Makes all ragdoll rigidbodies non-kinematic, disables the nav mesh agent, animator, and character controller
        foreach (var rigidbody in ragdollRigidbodies)
            rigidbody.isKinematic = false;

        navMeshAgent.enabled = false;
        animator.enabled = false;
        characterController.enabled = false;
    }
    // Method to check if there's a clear path to the target
    private bool HasClearPath()
    {
        // Calculates a path and checks if it's simple or mostly straight
        NavMesh.CalculatePath(transform.position, targetTransform.position, NavMesh.AllAreas, navMeshPath);

        // Check if the path is simple (mostly straight) or not
        if (navMeshPath.status == NavMeshPathStatus.PathComplete)
        {
            // You can define 'simplicity' based on the number of corners
            return navMeshPath.corners.Length <= 2 || IsPathMostlyStraight();
        }
        return false;
    }

    // Helper method to determine if the path is mostly straight
    private bool IsPathMostlyStraight()
    {
        // Checks the angle between path corners to determine if the path is mostly straight
        for (int i = 0; i < navMeshPath.corners.Length - 2; i++)
        {
            Vector3 directionToNextCorner = (navMeshPath.corners[i + 1] - navMeshPath.corners[i]).normalized;
            Vector3 directionToCornerAfterNext = (navMeshPath.corners[i + 2] - navMeshPath.corners[i + 1]).normalized;

            if (Vector3.Angle(directionToNextCorner, directionToCornerAfterNext) > 45) // Threshold angle
            {
                return false; // Path is not mostly straight
            }
        }
        return true; // Path is mostly straight
    }
    // Methods to start different AI behaviors (Walking, Running, Attacking)
    public void StartAiWalking()
    {
        // Sets up the zombie to start walking
        DisableRagdoll();
        animator.SetBool(isAttackingHash, false);
        animator.SetBool(isRunningHash, false);
        animator.SetBool(isWalkingHash, true);
        navMeshAgent.enabled = true;
        navMeshAgent.speed = walkingSpeed;
        navMeshAgent.angularSpeed = rotationSpeed;
        navMeshAgent.stoppingDistance = xzAttackProximity;

        currentState = ZombieState.AiWalking;
    }

    private void AiWalkingBehaviour()
    {
        // Behavior for AI walking, including transition to running or attacking
        float distanceToTarget = Vector3.Distance(transform.position, targetTransform.position);
        if (distanceToTarget > navMeshAgent.stoppingDistance)
        {
            if (distanceToTarget > runningOuterProximity && HasClearPath())
            {
                StartAiRunning();
            }
            else
            {
                navMeshAgent.SetDestination(targetTransform.position);
            }
        }
        else if (!playerHealth.isDead)
        {
            StartAiAttacking();
        }
    }

    private void StartAiRunning()
    {
        // Sets up the zombie to start running
        animator.SetBool(isAttackingHash, false);
        animator.SetBool(isWalkingHash, true);
        animator.SetBool(isRunningHash, true);
        navMeshAgent.speed = runningSpeed;
        navMeshAgent.enabled = true;
        navMeshAgent.speed = walkingSpeed;
        navMeshAgent.angularSpeed = rotationSpeed;
        navMeshAgent.stoppingDistance = xzAttackProximity;

        currentState = ZombieState.AiRunning;
    }

    private void RunningAiBehaviour()
    {
         // Behavior for AI running, including transition to walking or attacking
        float distanceToTarget = Vector3.Distance(transform.position, targetTransform.position);
        if (distanceToTarget > navMeshAgent.stoppingDistance)
        {
            if (!(distanceToTarget > runningOuterProximity && HasClearPath()))
            {
                StartAiWalking();
            }
            else
            {
                navMeshAgent.SetDestination(targetTransform.position);
            }
        }
        else if (!playerHealth.isDead)
        {
            StartAiAttacking();
        }
    }

    private void AttackAction()
    {
        // Method that handles the attack action, including playing sounds and dealing damage
        if (Time.time >= lastAttackSoundTime + attackSoundCooldown && !attackAudioSource.isPlaying)
        {
            attackAudioSource.Play();
            lastAttackSoundTime = Time.time;
            playerHealth.TakeDamage(5); //reduce player health
        }
    }

    private void StartAiAttacking()
    {
        // Sets up the zombie to start attacking
        animator.SetBool(isRunningHash, false);
        animator.SetBool(isWalkingHash, false);
        animator.SetBool(isAttackingHash, true);

        navMeshAgent.enabled = true;
        navMeshAgent.speed = walkingSpeed;
        navMeshAgent.angularSpeed = rotationSpeed;
        navMeshAgent.stoppingDistance = xzAttackProximity;

        currentState = ZombieState.AiAttacking;
    }
    // Behavior for AI attacking, including checking attack proximity and triggering the attack
    private void AiAttackingBehaviour()
    {
        // Calculate the differences in each axis
        float deltaX = Mathf.Abs(transform.position.x - targetTransform.position.x);
        float deltaY = Mathf.Abs(transform.position.y - targetTransform.position.y);
        float deltaZ = Mathf.Abs(transform.position.z - targetTransform.position.z);

        // Calculate the distance in the XZ plane
        float distanceXZ = Mathf.Sqrt(deltaX * deltaX + deltaZ * deltaZ);

        // Check if the zombie is within the specified proximities
        if (distanceXZ <= xzAttackProximity && deltaY <= yAttackProximity && !playerHealth.isDead)
        {
            AttackAction();
            animator.SetBool(isAttackingHash, true); // Trigger attack animation
            // After AiAttacking, you might want to switch back to AiWalking or another state
        }
        else
            StartAiWalking();
    }

    public void StartControlling()
    {
        // Sets up the zombie to be controlled manually
        animator.SetBool(isRunningHash, false);
        animator.SetBool(isWalkingHash, false);
        animator.SetBool(isAttackingHash, false);

        animator.enabled = true;
        characterController.enabled = true;
        navMeshAgent.enabled = false;
        currentState = ZombieState.Controlled;
    }
    // Behavior for manual control of the zombie, including movement and rotation
    private void ControllingBehaviour()
    {
        float rotationSpeed = 100f; // Adjust to your needs
        float rotationThreshold = 0.3f; // Dead zone threshold

        if (controlledMovementVector.x > rotationThreshold)
        {
            // Rotate to the right
            transform.Rotate(Vector3.up * rotationSpeed * Time.deltaTime);
        }
        else if (controlledMovementVector.x < -rotationThreshold)
        {
            // Rotate to the left
            transform.Rotate(Vector3.up * -rotationSpeed * Time.deltaTime);
        }

        if (controlledMovementVector.y != 0)
        {
            bool isWalking = animator.GetBool(isWalkingHash);
            bool isRunning = animator.GetBool(isRunningHash);

            Vector3 moveDirection = transform.forward * controlledMovementVector.y + transform.right * controlledMovementVector.x;
            moveDirection.Normalize(); // Ensure the movement speed is consistent

            // Apply movement speed
            //moveDirection *= controlledMovementSpeed;

            // Move the zombie using the CharacterController component
            characterController.Move(moveDirection * Time.deltaTime);

            // Set the animations
            if (!isWalking)
            {
                animator.SetBool(isWalkingHash, true);
            }
            else if (isControlledRunning && !isRunning && isWalking)
            {
                animator.SetBool(isRunningHash, true);
            }
        }
        else
        {
            // Stop if there's no movement
            animator.SetBool(isWalkingHash, false);
            animator.SetBool(isRunningHash, false);
            isControlledRunning = false;
        }
    }
    // Method to trigger running when the zombie is manually controlled
    public void OnControlledRun()
    {
        isControlledRunning = true;
    }
     // Method to trigger an attack when the zombie is manually controlled
    public void OnControlledAttack()
    {
        animator.SetBool(isAttackingHash, true);
        AttackAction();
    }
    // Method handling the zombie taking damage, including playing hurt sound and enabling ragdoll if dead
    public void TakeDamage(int amount)
    {
        hurtAudioSource.Play();
        currentHealth -= amount;
        if (currentHealth <= 0 && !isDead)
        {
            isDead = true;
            EnableRagdoll();
            currentState = ZombieState.Ragdoll;
        }
    }
    // Behavior when the zombie is in ragdoll state, applying a force to simulate a hit
    private void RagdollBehaviour()
    {
        Vector3 hitPoint = new Vector3(0, 0, 0); // Default hit point
        Vector3 force = new Vector3(0, 0.3f, 0); // Default force

        Rigidbody hitRigidbody = ragdollRigidbodies.OrderBy(rigidbody => Vector3.Distance(rigidbody.position, hitPoint)).First();
        hitRigidbody.AddForceAtPosition(force, hitPoint, ForceMode.Force);

        if (TryGetComponent(out Disolve disolve))
        {
            disolve.enabled = true;
        }
        if (TryGetComponent(out Outline outline))
        {
            outline.enabled = false;
        }
        Destroy(gameObject, 3.1f); 
    }
}
